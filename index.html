<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Cloud Platform</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/three@0.168.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.168.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.168.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.168.0/examples/js/shaders/CopyShader.js"></script>
</head>
<body>
    <canvas id="bg"></canvas>

    <main>
        <h1>Build and deploy on the AI Cloud.</h1>
        <p>
            Vercel provides the developer tools and cloud infrastructure to build, scale, 
            and secure a faster, more personalized web.
        </p>

        <div class="buttons">
            <button class="btn-primary">Deploy</button>
            <button class="btn-secondary">Get a Demo</button>
        </div>
    </main>

    <footer>
        <p>© 2025 Все права защищены</p>
    </footer>

    <script>
        // === Three.js сцена ===
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('bg'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;

        camera.position.z = 9;

        // === Стеклянная призма с преломлением (рефраクション) ===
        const tetraGeometry = new THREE.TetrahedronGeometry(2.5, 0);

        const tetraMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0,
            roughness: 0,
            transmission: 1.0,        // прозрачность
            thickness: 2.0,            // толщина для преломления
            clearcoat: 1.0,
            clearcoatRoughness: 0,
            ior: 1.5,                  // индекс преломления (стекло)
            envMapIntensity: 10,
            side: THREE.DoubleSide
        });

        const tetra = new THREE.Mesh(tetraGeometry, tetraMaterial);
        scene.add(tetra);

        // === Окружающая среда (чтобы было видно преломление) ===
        const envTexture = new THREE.CubeTextureLoader().load([
            'https://images.unsplash.com/photo-1506318137071-a8e063b4bec0?w=800',
            'https://images.unsplash.com/photo-1506318137071-a8e063b4bec0?w=800',
            'https://images.unsplash.com/photo-1506318137071-a8e063b4bec0?w=800',
            'https://images.unsplash.com/photo-1506318137071-a8e063b4bec0?w=800',
            'https://images.unsplash.com/photo-1506318137071-a8e063b4bec0?w=800',
            'https://images.unsplash.com/photo-1506318137071-a8e063b4bec0?w=800'
        ]);
        scene.background = new THREE.Color(0x000000);
        scene.environment = envTexture;

        // === Цветные лучи света (как на фото) ===
        const light1 = new THREE.PointLight(0x00ff88, 4, 50); // зелёный
        light1.position.set(-8, 3, 8);
        scene.add(light1);

        const light2 = new THREE.PointLight(0xff0066, 4, 50); // розовый
        light2.position.set(8, -3, 8);
        scene.add(light2);

        const light3 = new THREE.PointLight(0x4488ff, 3, 50); // синий
        light3.position.set(0, 8, 6);
        scene.add(light3);

        // === Анимация ===
        function animate() {
            requestAnimationFrame(animate);
            tetra.rotation.x += 0.004;
            tetra.rotation.y += 0.007;

            // Движение источников света
            const time = Date.now() * 0.001;
            light1.position.x = Math.sin(time) * 10;
            light1.position.y = Math.cos(time * 1.2) * 8;
            light2.position.x = Math.cos(time * 0.8) * 12;
            light2.position.y = Math.sin(time * 1.1) * 10;

            renderer.render(scene, camera);
        }
        animate();

        animate();

        // === Адаптация под размер экрана ===
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>
